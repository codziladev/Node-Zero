package model;

import java.io.*;
import java.net.URI;
import java.net.URL;
import java.net.URLConnection;
import java.nio.file.*;
import java.security.*;
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;

public class MalwareDetector {

    public enum Verdict {
        CLEAN, SUSPICIOUS, MALICIOUS, ERROR
    }

    public static final class Indicator {
        public final String layer;
        public final String type;
        public final String details;
        public final double confidence;

        public Indicator(String layer, String type, String details, double confidence) {
            this.layer = layer;
            this.type = type;
            this.details = details;
            this.confidence = confidence;
        }

        @Override
        public String toString() {
            return String.format("[%s] %s: %s (confidence: %.2f)", layer, type, details, confidence);
        }
    }

    public static final class Detection {
        public final Path file;
        public final Verdict verdict;
        public final List<Indicator> hits;
        public final String md5;
        public final String sha256;
        public final long size;
        public final Instant scanTime;
        public final Duration duration;

        public Detection(Path file, Verdict verdict, List<Indicator> hits, String md5, String sha256, long size, Instant scanTime, Duration duration) {
            this.file = file;
            this.verdict = verdict;
            this.hits = hits;
            this.md5 = md5;
            this.sha256 = sha256;
            this.size = size;
            this.scanTime = scanTime;
            this.duration = duration;
        }

        public Verdict verdict() {
            return verdict;
        }

        public List<Indicator> hits() {
            return hits;
        }

        public String sha256() {
            return sha256;
        }

        public Instant scanTime() {
            return scanTime;
        }
    }

    public interface SandboxRunner {
        BehaviorReport run(Path file, Duration timeout) throws Exception;
    }

    public static final class BehaviorReport {
        public final boolean malicious;
        public final double confidence;
        public final String summary;

        public BehaviorReport(boolean malicious, double confidence, String summary) {
            this.malicious = malicious;
            this.confidence = confidence;
            this.summary = summary;
        }

        public static BehaviorReport skipped(String reason) {
            return new BehaviorReport(false, 0.0, "SKIPPED: " + reason);
        }
    }

    public interface CloudIntelClient {
        CloudIntelResult lookupByHash(String sha256, String md5) throws Exception;
    }

    public static final class CloudIntelResult {
        public final Optional<String> malwareFamily;
        public final double maliciousScore;
        public final String source;

        public CloudIntelResult(Optional<String> family, double score, String source) {
            this.malwareFamily = family;
            this.maliciousScore = score;
            this.source = source;
        }

        public static CloudIntelResult none() {
            return new CloudIntelResult(Optional.empty(), 0.0, "none");
        }
    }

    public interface MLScorer {
        double score(Path file) throws Exception;
        String modelName();
    }

    public interface YaraEngine {
        YaraMatchResult match(Path file) throws Exception;
    }

    public static final class YaraMatchResult {
        public final boolean matched;
        public final List<String> ruleNames;
        public final String explain;

        public YaraMatchResult(boolean matched, List<String> ruleNames, String explain) {
            this.matched = matched;
            this.ruleNames = ruleNames;
            this.explain = explain;
        }

        public static YaraMatchResult noMatch() {
            return new YaraMatchResult(false, List.of(), "");
        }
    }

    public static final class SignatureDB {
        private final Set<String> md5 = ConcurrentHashMap.newKeySet();
        private final Set<String> sha256 = ConcurrentHashMap.newKeySet();
        private volatile Instant lastUpdated = Instant.EPOCH;

        public void addMD5(String h) {
            if (h != null && h.matches("(?i)[0-9a-f]{32}")) {
                md5.add(h.toLowerCase(Locale.ROOT));
            }
        }

        public void addSHA256(String h) {
            if (h != null && h.matches("(?i)[0-9a-f]{64}")) {
                sha256.add(h.toLowerCase(Locale.ROOT));
            }
        }

        public boolean containsMD5(String h) {
            return h != null && md5.contains(h.toLowerCase(Locale.ROOT));
        }

        public boolean containsSHA256(String h) {
            return h != null && sha256.contains(h.toLowerCase(Locale.ROOT));
        }

        public void clear() {
            md5.clear();
            sha256.clear();
        }

        public Instant lastUpdated() {
            return lastUpdated;
        }

        public void setLastUpdated(Instant t) {
            lastUpdated = t;
        }
    }

    public static final class Heuristics {
        private static final Pattern SUSPICIOUS_APIS = Pattern.compile(
                "CreateRemoteThread|WriteProcessMemory|VirtualAllocEx|LoadLibraryA|WinExec|RegSetValue|AddScheduledTask|MsiInstallProduct",
                Pattern.CASE_INSENSITIVE);

        public static List<Indicator> analyze(byte[] head, long size, List<String> strings) {
            List<Indicator> out = new ArrayList<>();

            // High entropy header (packed) heuristic
            double entropy = shannonEntropy(head);
            if (entropy > 7.3 && size > 50 * 1024) {
                out.add(new Indicator("HEURISTIC", "HighEntropyHeader", String.format(Locale.ROOT,
                        "Header entropy=%.2f (packed/obfuscated?)", entropy), 0.55));
            }

            // Suspicious Windows API names in strings
            for (String s : strings) {
                if (SUSPICIOUS_APIS.matcher(s).find()) {
                    out.add(new Indicator("HEURISTIC", "SuspiciousAPI", "Found: " + s, 0.6));
                    break;
                }
            }

            // Executable in user downloads with MZ header but no signature (very rough)
            if (size > 10 * 1024 && hasMZ(head)) {
                out.add(new Indicator("HEURISTIC", "MZHeader", "Executable header present", 0.4));
            }

            return out;
        }

        private static boolean hasMZ(byte[] head) {
            return head.length >= 2 && head[0] == 'M' && head[1] == 'Z';
        }

        private static double shannonEntropy(byte[] data) {
            int[] counts = new int[256];
            for (byte b : data) {
                counts[b & 0xFF]++;
            }
            double h = 0.0;
            int len = data.length;
            for (int c : counts) {
                if (c > 0) {
                    double p = (double) c / len;
                    h -= p * (Math.log(p) / Math.log(2));
                }
            }
            return h;
        }

        public static List<String> extractAsciiStrings(Path file, int minLen, int maxBytes) {
            List<String> out = new ArrayList<>();
            try (InputStream is = Files.newInputStream(file)) {
                ByteArrayOutputStream buf = new ByteArrayOutputStream();
                int read, total = 0;
                while ((read = is.read()) != -1 && total++ < maxBytes) {
                    if (read >= 32 && read <= 126) { // printable
                        buf.write(read);
                    } else {
                        if (buf.size() >= minLen) {
                            out.add(buf.toString());
                        }
                        buf.reset();
                    }
                }
                if (buf.size() >= minLen) {
                    out.add(buf.toString());
                }
            } catch (IOException ignored) {
            }
            return out;
        }
    }

    private final SignatureDB signatures;
    private final Optional<YaraEngine> yara;
    private final Optional<SandboxRunner> sandbox;
    private final Optional<CloudIntelClient> cloud;
    private final Optional<MLScorer> ml;
    private final ExecutorService pool;
    private final Map<Path, CachedResult> cache = new ConcurrentHashMap<>();

    private record CachedResult(Detection detection, long lastModified) {}

    public MalwareDetector(SignatureDB signatures,
                           Optional<YaraEngine> yara,
                           Optional<SandboxRunner> sandbox,
                           Optional<CloudIntelClient> cloud,
                           Optional<MLScorer> ml,
                           int threads) {
        this.signatures = signatures;
        this.yara = yara;
        this.sandbox = sandbox;
        this.cloud = cloud;
        this.ml = ml;
        this.pool = Executors.newFixedThreadPool(Math.max(1, threads));
    }

    public void shutdown() {
        pool.shutdownNow();
    }

    private Verdict fuse(List<Indicator> hits) {
        double score = 0.0;
        for (Indicator i : hits) {
            double w = switch (i.layer) {
                case "SIGNATURE" -> 1.0;
                case "YARA" -> 0.9;
                case "CLOUD" -> 0.8;
                case "ML" -> 0.7;
                case "HEURISTIC" -> 0.5;
                case "BEHAVIOR" -> 0.95;
                default -> 0.0;
            };
            score = Math.max(score, i.confidence * w);
        }
        if (score >= 0.9) {
            return Verdict.MALICIOUS;
        }
        if (score >= 0.6) {
            return Verdict.SUSPICIOUS;
        }
        return Verdict.CLEAN;
    }

    private static String hash(Path file, String algo) throws Exception {
        MessageDigest md = MessageDigest.getInstance(algo);
        try (InputStream is = Files.newInputStream(file); DigestInputStream dis = new DigestInputStream(is, md)) {
            byte[] buf = new byte[1 << 16];
            while (dis.read(buf) != -1) {
                /* streaming */ }
        }
        byte[] d = md.digest();
        StringBuilder sb = new StringBuilder();
        for (byte b : d) {
            sb.append(String.format(Locale.ROOT, "%02x", b));
        }
        return sb.toString();
    }

    private static byte[] readHead(Path file, int n) throws IOException {
        try (InputStream is = Files.newInputStream(file)) {
            byte[] buf = new byte[n];
            int r = is.read(buf);
            if (r <= 0) {
                return new byte[0];
            }
            return r == n ? buf : Arrays.copyOf(buf, r);
        }
    }

    private static boolean isPotentiallyExecutable(byte[] head, Path file) {
        String name = file.getFileName().toString().toLowerCase(Locale.ROOT);
        if (name.endsWith(".exe") || name.endsWith(".dll") || name.endsWith(".scr") ||
            name.endsWith(".bat") || name.endsWith(".cmd") || name.endsWith(".js") ||
            name.endsWith(".vbs") || name.endsWith(".ps1") || name.endsWith(".msi")) {
            return true;
        }
        return Heuristics.hasMZ(head);
    }

    // --- Updated and Improved Scanning Logic ---

    /**
     * Performs a fast scan using only signature checks.
     */
    public Detection scanFileFast(Path file) {
        long start = System.nanoTime();
        List<Indicator> hits = new ArrayList<>();
        String md5 = null, sha256 = null;
        long size = 0;
        try {
            size = Files.size(file);
            md5 = hash(file, "MD5");
            sha256 = hash(file, "SHA-256");

            if (signatures.containsMD5(md5)) {
                hits.add(new Indicator("SIGNATURE", "MD5", md5, 0.99));
            }
            if (signatures.containsSHA256(sha256)) {
                hits.add(new Indicator("SIGNATURE", "SHA256", sha256, 0.995));
            }

            Verdict verdict = fuse(hits);
            long end = System.nanoTime();
            Detection detection = new Detection(file, verdict, hits, md5, sha256, size, Instant.now(), Duration.ofNanos(end - start));
            cache.put(file, new CachedResult(detection, Files.getLastModifiedTime(file).toMillis()));
            return detection;
        } catch (Throwable t) {
            hits.add(new Indicator("ERROR", "SCAN", t.getMessage(), 0.0));
            long end = System.nanoTime();
            return new Detection(file, Verdict.ERROR, hits, md5, sha256, size, Instant.now(), Duration.ofNanos(end - start));
        }
    }

    /**
     * Performs a full, multi-layered scan.
     */
    public Detection scanFile(Path file) {
        long start = System.nanoTime();
        List<Indicator> hits = new ArrayList<>();
        String md5 = null, sha256 = null;
        long size = 0;
        try {
            // Check cache first for files that haven't been modified
            long lastModified = Files.getLastModifiedTime(file).toMillis();
            if (cache.containsKey(file) && cache.get(file).lastModified() == lastModified) {
                return cache.get(file).detection();
            }

            size = Files.size(file);
            byte[] head = readHead(file, 64 * 1024);
            List<String> strs = Heuristics.extractAsciiStrings(file, 5, 512 * 1024);

            // 1) Hashes (signatures)
            md5 = hash(file, "MD5");
            sha256 = hash(file, "SHA-256");
            if (signatures.containsMD5(md5)) {
                hits.add(new Indicator("SIGNATURE", "MD5", md5, 0.99));
            }
            if (signatures.containsSHA256(sha256)) {
                hits.add(new Indicator("SIGNATURE", "SHA256", sha256, 0.995));
            }

            // 2) YARA
            if (yara.isPresent()) {
                try {
                    YaraMatchResult yr = yara.get().match(file);
                    if (yr.matched) {
                        hits.add(new Indicator("YARA", String.join(",", yr.ruleNames), yr.explain, 0.9));
                    }
                } catch (Throwable t) {
                    hits.add(new Indicator("ERROR", "YARA", t.getMessage(), 0.0));
                }
            }

            // 3) Heuristics
            hits.addAll(Heuristics.analyze(head, size, strs));

            // 4) Cloud intel
            if (cloud.isPresent()) {
                try {
                    CloudIntelResult ci = cloud.get().lookupByHash(sha256, md5);
                    if (ci.maliciousScore > 0.5 || ci.malwareFamily.isPresent()) {
                        String fam = ci.malwareFamily.orElse("unknown");
                        hits.add(new Indicator("CLOUD", fam, "Source=" + ci.source + ", score=" + ci.maliciousScore, 0.85));
                    }
                } catch (Throwable t) {
                    hits.add(new Indicator("ERROR", "CLOUD", t.getMessage(), 0.0));
                }
            }

            // 5) ML model
            if (ml.isPresent()) {
                try {
                    double p = ml.get().score(file);
                    hits.add(new Indicator("ML", ml.get().modelName(), String.format(Locale.ROOT, "p=%.3f", p), Math.min(1.0, Math.max(0.0, p))));
                } catch (Throwable t) {
                    hits.add(new Indicator("ERROR", "ML", t.getMessage(), 0.0));
                }
            }

            // 6) Behavioral (sandbox)
            if (sandbox.isPresent() && isPotentiallyExecutable(head, file)) {
                try {
                    BehaviorReport br = sandbox.get().run(file, Duration.ofSeconds(120));
                    if (br.malicious) {
                        hits.add(new Indicator("BEHAVIOR", "Sandbox", br.summary, br.confidence));
                    }
                } catch (Throwable t) {
                    hits.add(new Indicator("ERROR", "SANDBOX", t.getMessage(), 0.0));
                }
            }

            Verdict verdict = fuse(hits);
            long end = System.nanoTime();
            Detection detection = new Detection(file, verdict, hits, md5, sha256, size, Instant.now(), Duration.ofNanos(end - start));
            cache.put(file, new CachedResult(detection, lastModified));
            return detection;
        } catch (Throwable t) {
            hits.add(new Indicator("ERROR", "SCAN", t.getMessage(), 0.0));
            long end = System.nanoTime();
            return new Detection(file, Verdict.ERROR, hits, md5, sha256, size, Instant.now(), Duration.ofNanos(end - start));
        }
    }
    
    /**
     * Scans a folder in parallel using a thread pool.
     */
    public List<Detection> scanFolder(Path root, Predicate<Path> include, int maxDepth) throws IOException, InterruptedException {
        List<Future<Detection>> futures = new ArrayList<>();
        try (Stream<Path> stream = Files.walk(root, maxDepth)) {
            stream.filter(Files::isRegularFile)
                  .filter(include)
                  .forEach(p -> futures.add(pool.submit(() -> scanFile(p))));
        }
        List<Detection> out = new ArrayList<>();
        for (Future<Detection> f : futures) {
            try {
                out.add(f.get());
            } catch (ExecutionException e) {
                System.err.println("Error during parallel scan: " + e.getCause().getMessage());
            }
        }
        return out;
    }

    public static final class FeedUpdater {
        private final SignatureDB db;

        public FeedUpdater(SignatureDB db) {
            this.db = db;
        }

        public void updateFromMalwareBazaar() throws IOException {
            fetchAndIngest("https://bazaar.abuse.ch/export/txt/md5/recent/", db::addMD5);
            fetchAndIngest("https://bazaar.abuse.ch/export/txt/sha256/recent/", db::addSHA256);
            db.setLastUpdated(Instant.now());
        }

        private void fetchAndIngest(String url, Consumer<String> sink) throws IOException {
            URL u = URI.create(url).toURL();
            URLConnection c = u.openConnection();
            c.setConnectTimeout(10000);
            c.setReadTimeout(20000);
            try (BufferedReader br = new BufferedReader(new InputStreamReader(c.getInputStream()))) {
                String line;
                while ((line = br.readLine()) != null) {
                    line = line.trim();
                    if (line.isEmpty() || line.startsWith("#")) {
                        continue;
                    }
                    sink.accept(line);
                }
            }
        }
    }

    public static final class NoopYara implements YaraEngine {
        @Override
        public YaraMatchResult match(Path file) {
            return YaraMatchResult.noMatch();
        }
    }

    public static final class NoopCloud implements CloudIntelClient {
        @Override
        public CloudIntelResult lookupByHash(String sha256, String md5) {
            return CloudIntelResult.none();
        }
    }

    public static final class NoopSandbox implements SandboxRunner {
        @Override
        public BehaviorReport run(Path file, Duration timeout) {
            return BehaviorReport.skipped("sandbox not configured");
        }
    }

    public static final class NoopML implements MLScorer {
        @Override
        public double score(Path file) {
            return 0.0;
        }

        @Override
        public String modelName() {
            return "none";
        }
    }

    public static final class Builder {
        private final SignatureDB sigs = new SignatureDB();
        private YaraEngine yara = null;
        private SandboxRunner sandbox = null;
        private CloudIntelClient cloud = null;
        private MLScorer ml = null;
        private int threads = Math.max(2, Runtime.getRuntime().availableProcessors());

        public Builder withYara(YaraEngine y) {
            this.yara = y;
            return this;
        }

        public Builder withSandbox(SandboxRunner s) {
            this.sandbox = s;
            return this;
        }

        public Builder withCloud(CloudIntelClient c) {
            this.cloud = c;
            return this;
        }

        public Builder withML(MLScorer m) {
            this.ml = m;
            return this;
        }

        public Builder threads(int n) {
            this.threads = n;
            return this;
        }

        public SignatureDB signatures() {
            return sigs;
        }

        public MalwareDetector build() {
            return new MalwareDetector(sigs,
                    Optional.ofNullable(yara),
                    Optional.ofNullable(sandbox),
                    Optional.ofNullable(cloud),
                    Optional.ofNullable(ml),
                    threads);
        }
    }
}