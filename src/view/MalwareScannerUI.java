package view;

import model.MalwareDetector;
import model.MalwareDetector.Detection;
import model.MalwareDetector.Verdict;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.List;
import java.util.concurrent.*;
import java.util.stream.Stream;

public class MalwareScannerUI extends JFrame {
    private JButton scanButton;
    private JTextArea resultArea;
    private JProgressBar progressBar;
    private MalwareDetector detector;

    public MalwareScannerUI() {
        MalwareDetector.Builder builder = new MalwareDetector.Builder();
        this.detector = builder.build();
        setupUI();
    }

    private void setupUI() {
        setTitle("Advanced Malware Scanner");
        setSize(800, 600);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());

        // Top panel with scan button
        JPanel topPanel = new JPanel();
        scanButton = createScanButton();
        topPanel.add(scanButton);
        add(topPanel, BorderLayout.NORTH);

        // Center panel with results
        resultArea = new JTextArea();
        resultArea.setEditable(false);
        resultArea.setFont(new Font("Monospaced", Font.PLAIN, 12));
        add(new JScrollPane(resultArea), BorderLayout.CENTER);

        // Bottom progress bar
        progressBar = new JProgressBar();
        progressBar.setStringPainted(true);
        add(progressBar, BorderLayout.SOUTH);

        setLocationRelativeTo(null);
    }

    private JButton createScanButton() {
        JButton button = new JButton("FULL SYSTEM SCAN (HIGH LEVEL)");
        button.setFont(new Font("Arial", Font.BOLD, 16));
        button.setBackground(new Color(220, 50, 50));
        button.setForeground(Color.WHITE);
        button.addActionListener(e -> startFullSystemScan());
        return button;
    }

    private void startFullSystemScan() {
        scanButton.setEnabled(false);
        resultArea.setText("");
        progressBar.setValue(0);

        new SwingWorker<Void, String>() {
            private int totalFiles = 0;
            private int scannedFiles = 0;

            @Override
            protected Void doInBackground() {
                publish("=== Starting Full System Scan ===\n");
                scanAllRootDrives();
                return null;
            }

            private void scanAllRootDrives() {
                File[] roots = File.listRoots();
                for (File root : roots) {
                    handleDriveScan(root.toPath());
                }
            }

            private void handleDriveScan(Path drive) {
                if (!isDriveAccessible(drive)) {
                    publish("[SKIPPED] " + drive + " (device not ready or no permission)\n");
                    return;
                }

                try {
                    countFiles(drive);
                    scanFiles(drive);
                } catch (IOException e) {
                    publish("[ERROR] Scanning " + drive + ": " + e.getMessage() + "\n");
                }
            }

            private boolean isDriveAccessible(Path path) {
                try {
                    Files.getFileStore(path);
                    return true;
                } catch (IOException e) {
                    return false;
                }
            }
            
            // Re-written method using a SimpleFileVisitor to count files
            private void countFiles(Path root) throws IOException {
                publish("\n[SCANNING] " + root + "\n");
                try {
                    Files.walkFileTree(root, new SimpleFileVisitor<Path>() {
                        @Override
                        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                            if (shouldSkipPath(dir)) {
                                return FileVisitResult.SKIP_SUBTREE;
                            }
                            return FileVisitResult.CONTINUE;
                        }

                        @Override
                        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                            if (Files.isRegularFile(file) && Files.isReadable(file)) {
                                totalFiles++;
                            }
                            return FileVisitResult.CONTINUE;
                        }

                        @Override
                        public FileVisitResult visitFileFailed(Path file, IOException exc) {
                            if (exc instanceof AccessDeniedException) {
                                // Silently ignore access denied files for the count
                                return FileVisitResult.CONTINUE;
                            }
                            return FileVisitResult.CONTINUE;
                        }
                    });
                    publish("Found " + totalFiles + " files to scan\n");
                } catch (AccessDeniedException e) {
                    publish("[WARNING] Partial access to " + root + " (some files skipped)\n");
                }
            }

            // The main scan method using a SimpleFileVisitor
            private void scanFiles(Path root) throws IOException {
                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {
                    @Override
                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
                        if (shouldSkipPath(dir)) {
                            publish("[SKIPPING] Directory: " + dir + "\n");
                            return FileVisitResult.SKIP_SUBTREE;
                        }
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                        if (Files.isRegularFile(file) && Files.isReadable(file)) {
                            scanSingleFile(file);
                        }
                        return FileVisitResult.CONTINUE;
                    }

                    @Override
                    public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
                        if (exc instanceof AccessDeniedException) {
                            publish("[ACCESS DENIED] Could not access: " + file + "\n");
                            return FileVisitResult.CONTINUE;
                        }
                        throw exc; // Re-throw other errors
                    }
                });
            }

            private boolean shouldSkipPath(Path path) {
                String pathStr = path.toString().toLowerCase();
                return pathStr.contains("system volume information") ||
                       pathStr.contains("documents and settings") ||
                       pathStr.contains("$recycle.bin") ||
                       pathStr.contains("windows\\system32");
            }

            private void scanSingleFile(Path file) {
                try {
                    Detection detection = detector.scanFile(file);
                    updateProgress();
                    reportMaliciousFiles(detection, file);
                } catch (Exception e) {
                    publish("[ERROR] Failed to scan " + file + ": " + e.getMessage() + "\n");
                }
            }

            private void updateProgress() {
                scannedFiles++;
                int progress = totalFiles > 0 ? (scannedFiles * 100) / totalFiles : 0;
                progressBar.setValue(progress);
            }

            private void reportMaliciousFiles(Detection detection, Path file) {
                if (detection.verdict() != Verdict.CLEAN) {
                    String result = String.format(
                        "\n[MALICIOUS] %s\nSHA256: %s\nVerdict: %s\nDetails: %s\n",
                        file, detection.sha256(), detection.verdict(), detection.hits()
                    );
                    publish(result);
                }
            }

            @Override
            protected void process(List<String> chunks) {
                chunks.forEach(resultArea::append);
                resultArea.setCaretPosition(resultArea.getDocument().getLength());
            }

            @Override
            protected void done() {
                try {
                    get();
                    publish("\n=== Scan Complete ===\n");
                    publish("Scanned " + scannedFiles + "/" + totalFiles + " files\n");
                } catch (Exception e) {
                    publish("\n=== Scan Failed ===\n" + e.getMessage() + "\n");
                } finally {
                    scanButton.setEnabled(true);
                    progressBar.setValue(100);
                }
            }
        }.execute();
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> new MalwareScannerUI().setVisible(true));
    }
}